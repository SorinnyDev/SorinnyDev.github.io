---
layout: post
title: 메모리의 구조
author: "Sorinny"
categories: [CS]
image: 
tags: [CS]
featured: true
hidden: true
---

## 메모리의 구조

---
###메모리의 구조
프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드(Load) 되어야 합니다.  
또한, 프로그램에서 사용되는 변수들을 저장할 메모리공간도 필요합니다.  

따라서 컴퓨터 운영체제는 프로그램의 실행을 위해서 다양한 메모리 공간을 제공합니다.  
프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 다음과 같습니다.  

1.코드(code) 영역  
2.데이터(data) 영역  
3.스택(stack) 영역  
4.힙(heap) 영역  

다음 그림은 운영체제가 제공하는 메모리 공간을 표현하고 있습니다.

![운영체제에서 할당받는 메모리 공간](/assets/images/2022-01-20-CS_메모리의구조_01_memory_structure.png)  

---

###코드(code) 영역
메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.  
CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

---

###데이터(data) 영역
메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.  
데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

---

###스택(stack) 영역
메모리의 스택(stack) 영역은 함수의 호출과 관계되는 **지역 변수와 매개변수** 가 저장되는 영역입니다.  
스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.  
이렇게 스택 영역에 저장되는 함수의 호출 정보를 **스택 프레임(stack frame)** 이라고 합니다.  

스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.  
이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.  
스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.  
<u>___컴파일___</u> 시에 할당될 영역의 크기가 결정됩니다.  
운영체제에 따라 제한된 스택 영역의 크기가 다르고, 이 <u>**크기를 초과해 push 할 수 없습니다.**</u>

---

###힙(heap) 영역
메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 '그리고 해야만 하는' 메모리 영역입니다.  
힙 영역은 **사용자에 의해 메모리 공간이 동적으로 할당되고 해제** 됩니다.  
힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.  

`class` `closure` 와 같은 참조 타입의 데이터가 저장됩니다.
 - Java의 경우 가바지 콜렉터 가 관리
 - Swift의 경우 **ARC** 가 참조 타입의 할당, 해제 시점을 자동 관리
 - C의 경우 사용자가 동적으로 할당, 해제 해줘야함
 
**런타임** 시(프로그램이 실행되는 도중)에 힙 영역의 크기가 결정된다.


---

###Stack 영역 vs Heap 영역
**스택 영역** 과 **힙 영역** 은 사실상 **같은 공간을 사용** 합니다.  
그래서 스택 영역이 커질수록 힙 영역이 작아지고,  
힙 영역이 커질수록 스택 영역이 작아집니다. (의자뺏기? 땅따먹기?)

Why?  
스택 영역은 높은 주소-> 낮은 주소 로 할당되고,  
힙 영역은 낮은 주소 -> 높은 주소 로 할당 되기 때문에
서로 상대의 영역을 침범하는 상황도 발생 될수 있습니다.  
이를 각각 `스택 오버플로우`, `힙 오버플로우` 라고 합니다.

**할당 속도 비교**  
스택은 컴파일시 이미 할당된 공간을 사용합니다.
- 스택에서 말하는 할당이란 이미 생성된 스택에 대해 포인터의 위치만 바꿔주는 단순한 CPU Instruction을 말합니다.

힙은 사용자가 따로 할당해서 사용하는 공간입니다.
- 힙에서의 할당이란 요청된 chunk의 크기, 현재 메모리의 fragmentation 상황 등 다양한 요소를 고려하기 때문에 더 많은 CPU Instruction을 필요로 합니다.

결론 <u>**스택의 할당속도가 더 빠르다아~**</u>

---

**Swift ARC VS Java 가비지 콜렉터**  

**ARC**
- 힙 영역의 데이터들이 얼마나 첨조되고 있는지 count해서 메모리 할당/해제 를 관리
- 컴파일 시에 reference counting 을 함
- 컴파일 시 인스턴스 해제 시점을 알기 때문에 언제 이 인스턴스가 메모리에서 해제 될지 예측할 수 있다.
- 메모리 관리를 위한 스스템 자원을 추가할 필요가 없다.

**가비지 콜렉터**
- 프로그램 동작 중에 reference counting
- 프로그램을 동작할 때, 메모리 감시를 위한 추가 자원이 필요하다.
- 명확한 규칙이 없기 때문에 인스턴스가 언제 메모리를 할당하고 해제하는지 예측 할 수 없음.
- 사용자가 임의로 System.gc() 명령어로 호출 할수 있지만
- System.gc() 를 호출하여 명시적으로 가비지 컬렉션이 일어나도록 코드를 삽입할 수 있지만,  
   모든 스레드가 중단되기 때문에 코드단에서 호출하는 짓은 하면 안된다.



####참조
>[메모리의 구조](http://www.tcpschool.com/c/c_memory_structure)  
>[메모리 구조](https://velog.io/@goserimgoserimgo/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)  
>[자바 메모리 관리 - 가비지 컬렉션](https://yaboong.github.io/java/2018/06/09/java-garbage-collection/)  
